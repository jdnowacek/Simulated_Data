---
title: "JohnsonBook_ztnbinom_ftns"
format: html
editor: source
---

## Packages

```{r}
library(tidyverse)
library(knitr)
```

## D function

defines a function that returns the probability of an input value, k, in the zero-truncated negative binomial function with the specified p and N

```{r}
d_ztbinom_book <- function(k, N, p) {
  
  generalized_choose <- function(n, k) {
  return(exp(lgamma(n + 1) - lgamma(k + 1) - lgamma(n - k + 1)))
  }
  
  prob = (1/(1-((1+p)^-N))) * generalized_choose(n = N+k-1, k = N-1) * (p/(1+p))^k * (1 - (p/(1+p)))^N
  
  return(prob)
}
```

```{r}
d_ztbinom_book(3, 0.5, 10)
```

## CDF function

defines a function that returns the cumulative probability up to an input value, k, in the zero-truncated negative binomial function with the specified p and N

```{r}
cdf_ztbinom_book <- function(k, N, p) {
  
  cumulative_prob <- 0
  for (i in 1:k) {
    cumulative_prob = cumulative_prob + d_ztbinom_book(i, N, p)
  }
  
  return(cumulative_prob)
}
```

## Mean function

calculates the mean of the ztnbinom function based on the parameters, p and N, input

```{r}
mean_ztbinom_book <- function(N, p) {

  mean = N*p / (1-((1+p)^-N))
  
  return(mean)
}
```

## Variance function

calculates the variance of the ztnbinom function based on the parameters, p and N, input

```{r}
var_ztbinom_book <- function(N, p) {

  var = ( (N*p*(1+p)) / (1-((1+p)^-N)) ) * ( 1 - (N*p / (1+p)) * ( 1 / (1-((1+p)^-N)) - 1)  )
  
  return(var)
}
```

### Testing those functions

tests the functions with a specific use case

```{r}
d_ztbinom_book(k = 3, p = 0.5, N = 10)

cdf_ztbinom_book(k = 25, p = 0.5, N = 10)

mean_ztbinom_book(p = 0.5, N = 10)

var_ztbinom_book(p = 0.5, N = 10)
```

## R function

defines a function that returns n draws from a zero truncated negative binomial distribution with the input p and N as parameters.

```{r}
r_ztbinom_book <- function(n, N, p) {
  
  set.seed(7)
  
  # 'price is right' function
  # takes a value x, and a vector y, finds and returns the y value for which
  # x is closest to without going over
  
  pir <- function(x, y){
    
    val <- min(y[y >= x])

    # y <- y - x
    # val <- min(y[y > 0])
    # val <- val + x
    return(val)
  }

  # sets upper bound for how many cdf values to calculate, keeps sampler fast
  upper = N*10
  
  cdf_vals <- rep(0, upper)
  return_vals <- rep(0, upper)
  
  for (i in 1:upper) {
    return_vals[i] <- i
    cdf_vals[i] <- cdf_ztbinom_book(k = i, N = N, p = p)
  }
  
  tab <- tibble(return_vals, cdf_vals)
  
  
  # sets bounds for upper and lower limit of the unif() draw function for the 
  # inverse cdf sampler
  
  # min = cdf_ztbinom_book(k = 1, p = N, p = N)
  min = 0
  max = cdf_ztbinom_book(k = upper, p = N, p = N) # can do e^huge
  draws <- rep(0, n)
  
  for (i in 1:n) {
    unif_draw <- runif(n = 1, min = min, max = max)
    
    # which value of the cdf is just higher than this value
    
    cdf_val_of_draw <- pir(unif_draw, cdf_vals)
    
    draw <- tab$return_vals[tab$cdf_vals == cdf_val_of_draw]
    
    draws[i] <- draw
  }
  return(draws)
}
```

## Function to find N and p from mean and variance

Find parameters to best fit a desired mean and variance

```{r}
find_parameters <- function(desired_mean, desired_var) {
  
  # minimize the difference between calculated and desired mean and variance
  error_ftn <- function(params) {
    
    N <- params[1]
    p <- params[2]
    
    book_mean <- mean_ztbinom_book(N, p)
    book_var  <- var_ztbinom_book(N, p)
    
    error <- (book_mean - desired_mean)^2 + (book_var - desired_var)^2
    return(error)
  }
  
  start_guesses <- c(desired_mean*0.9, (2.096 - 2.362*(desired_mean/desired_var)))
  
  result <- optim(
    par = start_guesses,
    fn = error_ftn,
    method = "L-BFGS-B",
    lower = c(0.001, 0.001), 
    upper = c(Inf, 0.99999)
  )
  
  return(list(
    Estimated_N = result$par[1],
    Estimated_p = result$par[2],
    Goodness_of_Fit = result$value 
  ))
}
```

```{r}
find_parameters(5, 7)
```

### Testing

Set of testing cases for the find_parameters function

```{r}
# # ---------------------------------------------------------
# # 3. Diagnostic Test Suite
# # ---------------------------------------------------------
# 
# # Define a set of target Means and Variances to test
# # Note: For Negative Binomial, Variance usually must be > Mean
# test_scenarios <- tribble(
#   ~Target_Mean, ~Target_Var,
#   1.4,          2,
#   5,            8,
#   5,            9,
#   5,            10,
#   100,          120,
# )
# 
# # Function to run a single diagnostic row
# run_diagnostic <- function(t_mean, t_var) {
#   
#   # 1. Solve for N and P
#   params <- find_parameters(t_mean, t_var)
#   
#   est_n <- params$Estimated_N
#   est_p <- params$Estimated_P
#   
#   # 3. Generate Simulation
#   # Using the user's r_ztbinom_book function
#   # We generate a large sample size (n=50,000) to ensure stability of the sim mean/var
#   sim_values <- r_ztbinom_book(n = 500000, N = est_n, p = est_p)
#   
#   # 4. Calculate Simulated Metrics
#   sim_mean <- mean(sim_values)
#   sim_var  <- var(sim_values)
#   
#   # 5. Return Row
#   tibble(
#     Target_Mean = t_mean,
#     Target_Var  = t_var,
#     Estimated_N = est_n,
#     Estimated_P = est_p,
#     check_Mean = sim_mean,
#     check_Var = sim_var,
#     # Calculate % error between Input Mean and Sim Mean
#     Mean_Diff_Pct = paste0(round(((sim_mean - t_mean) / t_mean) * 100, 2), "%"),
#     Var_Diff_Pct = paste0(round(((sim_var - t_var) / t_var) * 100, 2), "%")
#   )
# }
# 
# # Execute the tests across all scenarios
# results_table <- test_scenarios |>
#   pmap_dfr(function(Target_Mean, Target_Var) {
#     run_diagnostic(Target_Mean, Target_Var)
#   })
# 
# # ---------------------------------------------------------
# # 4. Output Formatted Table
# # ---------------------------------------------------------
# 
# results_table
```
