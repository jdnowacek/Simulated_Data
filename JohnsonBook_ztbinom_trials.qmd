---
title: "JohnsonBook_ztbinom_trials"
format: html
---

```{r}
library(tidyverse)
```

```{r}
d_ztbinom_book <- function(k, p, N) {
  q = p + 1
  
  prob = (1/(1-(q^-N))) * choose(n = N+k-1, k = N-1) * (p/q)^k * (1 - (p/q))^N
  
  return(prob)
}
```

```{r}
cdf_ztbinom_book <- function(k, p, N) {
  q = p + 1
  
  cumulative_prob <- 0
  for (i in 1:k) {
    cumulative_prob = cumulative_prob + d_ztbinom_book(i, p, N)
  }
  
  return(cumulative_prob)
}
```

```{r}
mean_ztbinom_book <- function(p, N) {
  q = p + 1
  
  mean = N*p / (1-(q^-N))
  
  return(mean)
}
```

```{r}
var_ztbinom_book <- function(p, N) {
  q = p + 1
  
  var = ( (N*p*q) / (1-(q^-N)) ) * ( 1 - (N*p / q) * ( 1 / (1-(q^-N)) - 1)  )
  
  return(var)
}
```

```{r}
d_ztbinom_book(k = 3, p = 0.5, N = 10)

cdf_ztbinom_book(k = 25, p = 0.5, N = 10)

mean_ztbinom_book(p = 0.5, N = 10)

var_ztbinom_book(p = 0.5, N = 10)
```

```{r}
# pdf build

pdf <- d_ztbinom_book(k = seq(1, 20, 1), p = 0.5, N = 10)

pdf_df <- as.data.frame(pdf)

pdf_df <- pdf_df |>
  mutate(k = seq(1, 20, 1)) |>
  rename(prob = pdf)

pdf_df |>
  ggplot(aes(x = k, y = prob)) +
  geom_line() +
  theme_bw() 

sum(pdf)
```
```{r}
cdf <- rep(0, 20)

for (i in 1:20) {
  cdf[i] <- cdf_ztbinom_book(k = i, p = 0.5, N = 10)
}

cdf_df <- as.data.frame(cdf)

cdf_df <- cdf_df |>
  mutate(k = seq(1, 20, 1)) |>
  rename(prob = cdf)
```

```{r}
cdf_df |>
  ggplot(aes(x = k, y = prob)) +
  geom_line() +
  theme_bw() +
  scale_x_continuous(breaks = seq(0, 20, 1)) +
  scale_y_continuous(breaks = seq(-0.1, 1, 0.1))
```

```{r}
r_ztbinom_book <- function(n, p, N) {
  
  draws <- rep(NA, n)
  
  upper = N*10
  
  min = cdf_ztbinom_book(k = 1, p = p, N = N)
  max = cdf_ztbinom_book(k = upper, p = p, N = N)
  
  cdf_vals <- rep(0, upper)
  
  for (i in 1:upper) {
    cdf_vals[i] <- cdf_ztbinom_book(k = i, p = p, N = N)
  }
  
  for (i in 1:n) {
    unif_draw <- runif(n = 1, min = min, max = max)
    
    dist_to_0 = cdf_vals - unif_draw
    
    draw <- which.min(abs(dist_to_0))
    
    draws[i] <- draw
  }
  return(draws)
}
```

```{r}
set.seed(1)

n = 100000
N = 18
p = 0.75

# pdf <- d_ztbinom_book(k = seq(1, N*10, 1), p = p, N = N)
# 
# pdf_df <- as.data.frame(pdf)
# 
# pdf_df <- pdf_df |>
#   mutate(k = seq(1, N*10, 1)) |>
#   rename(prob = pdf)
# 
# pdf_df |>
#   ggplot(aes(x = k, y = prob)) +
#   geom_line() +
#   theme_bw() 

d <- r_ztbinom_book(n, p, N)

draws <- as.data.frame(d) |>
  rename(draws = d) 

draws |>
  ggplot(aes(x = draws)) +
  geom_histogram(binwidth = 1) +
  theme_bw() 
```

```{r}
mean(draws$draws)
var(draws$draws)
```

```{r}
pdf <- d_ztbinom_book(k = seq(1, 20, 1), p = 0.5114, N = 9.2648)

pdf_df <- as.data.frame(pdf)

pdf_df <- pdf_df |>
  mutate(k = seq(1, 20, 1)) |>
  rename(prob = pdf)

pdf_df |>
  ggplot(aes(x = k, y = prob)) +
  geom_line() +
  theme_bw() 

# sum(pdf)
```

$$
0 = NP(1+P)^{4n+1} + N^2P^2(1+P)^{4n} - 2NP(1+P)^{3n+1} - (1+P)^{3n+1} - 2N^2P^2(1+P)^{3n}
 - NP(1+P)^{3n} - 2N^2P^2(1+P)^{3n-1} + NP(1+P)^{2n+1} - 2(1+P)^{2n+1}
 + 2N^2P^2(1+P)^{2n} + 5NP(1+P)^{2n} + 4N^2P^2(1+P)^{2n-1} - 2NP(1+P)^{n+1}
 + (1+P)^{n+1} - 2N^2P^2(1+P)^{n} - NP(1+P)^{n} - 2N^2P^2(1+P)^{n-1}
 + NP(1+P) + N^2P^2
$$

$$
\frac{NP(1+P)}{1 - (1+P)^{-n}}
\left[
1 - \left(\frac{NP}{1+P}\right)
\left(\frac{1}{1 - (1+P)^{-n}} - 1\right)
\right]
=
\left(NP(1+P) + (NP)^2\right)
\frac{1}{1 - (1+P)^{-n}}
- \left(
\frac{NP}{1 - (1+P)^{-n}}
\right)^2

$$

# Optimization

```{r}
# Define the system of equations (to be solved for roots)
# The function must return a vector of residuals (errors)
zt_system_of_eq <- function(vars, mu_obs, sigma_sq_obs) {
    
    # 1. Assign parameters (N and P are the unknowns)
    N <- vars[1]
    P <- vars[2]
    
    # --- Constraint Checks ---
    # Since N and P must be positive, return a massive error if they are not.
    if (N <= 0 || P <= 0) {
        return(c(1e+10, 1e+10))
    }
    
    # --- Calculation of Residuals ---
    
    # Term: (1 + P)^(-N)
    common_exp <- (1 + P)^(-N)
    
    # Residual 1: Mean Equation
    # f1(N, P) = [NP / (1 - (1+P)^-N)] - mu_obs = 0
    f1_residual <- (N * P / (1 - common_exp)) - mu_obs
    
    # Residual 2: Simplified Variance Equation
    # f2(N, P) = [mu_obs*(1+P) - mu_obs^2 * (1+P)^-N] - sigma_sq_obs = 0
    f2_residual <- (mu_obs * (1 + P) - mu_obs^2 * common_exp) - sigma_sq_obs
    
    # The solver aims to make both of these residuals zero
    return(c(f1_residual, f2_residual))
}
```

```{r}
# Load the necessary library
library(rootSolve)

# --- USER INPUTS ---
# Replace these with your observed values
observed_mean <- 12.99958
observed_variance <- 23.96926

# --- INITIAL GUESS ---
# A crucial step. [N_guess, P_guess]
initial_guess <- c(10.0, 0.5) 

# --- Solve the system ---
solution <- multiroot(
    f = zt_system_of_eq,        # The function containing the equations
    start = initial_guess,      # The initial guess for [N, P]
    mu_obs = observed_mean,
    sigma_sq_obs = observed_variance) # The fixed parameters (mu, sigma^2)

# --- Output Results ---
print(solution)

# Access the final parameters:
N_final <- solution$root[1]
P_final <- solution$root[2]

cat(sprintf("\nOptimized Parameters:\n N = %.4f\n P = %.4f\n", N_final, P_final))
```

















